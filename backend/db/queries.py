# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: queries.sql
import dataclasses
from typing import Iterator, Optional

import sqlalchemy

from db import models


GET_ALL_COURSE_CALENDARS = """-- name: get_all_course_calendars \\:many
SELECT
    id,
    calendar_url
FROM courses
WHERE calendar_url IS NOT NULL
ORDER BY id ASC
"""


@dataclasses.dataclass()
class GetAllCourseCalendarsRow:
    id: str
    calendar_url: Optional[str]


GET_COURSE_I_CAL = """-- name: get_course_i_cal \\:one
SELECT ics_string
FROM calendars
WHERE course_id = :p1
"""


GET_COURSES_LIST = """-- name: get_courses_list \\:many
SELECT
    c.id,
    c.name,
    l.name as level,
    CASE
        WHEN c.calendar_url IS NOT NULL THEN 1
        ELSE 0
    END as calendar_available,
    c.last_sync_at
FROM courses c
JOIN level l ON c.level_id = l.id
ORDER BY c.id ASC
"""


@dataclasses.dataclass()
class GetCoursesListRow:
    id: str
    name: Optional[str]
    level: Optional[str]
    calendar_available: int
    last_sync_at: Optional[str]


LOGIN_USER = """-- name: login_user \\:one
INSERT INTO users (
    first_name,
    last_name,
    email,
    last_login_at
)
VALUES (
    :p1,
    :p2,
    :p3,
    CURRENT_TIMESTAMP
)
ON CONFLICT (email) DO UPDATE
SET
    first_name = :p1,
    last_name = :p2,
    last_login_at = CURRENT_TIMESTAMP
RETURNING
    id,
    first_name,
    last_name,
    email,
    calendar_token,
    last_login_at,
    last_calendar_sync_at
"""


UPDATE_CALENDAR_SYNC_STATUS = """-- name: update_calendar_sync_status \\:exec
UPDATE courses
SET
    last_sync_at = :p1,
    last_sync_http_status = :p2
    WHERE id = :p3
"""


UPDATE_COURSE_I_CAL = """-- name: update_course_i_cal \\:exec
INSERT INTO calendars (course_id, ics_string)
VALUES (:p1, :p2)
ON CONFLICT (course_id) DO UPDATE
SET ics_string = :p2
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_all_course_calendars(self) -> Iterator[GetAllCourseCalendarsRow]:
        result = self._conn.execute(sqlalchemy.text(GET_ALL_COURSE_CALENDARS))
        for row in result:
            yield GetAllCourseCalendarsRow(
                id=row[0],
                calendar_url=row[1],
            )

    def get_course_i_cal(self, *, course_id: Optional[str]) -> Optional[Optional[str]]:
        row = self._conn.execute(sqlalchemy.text(GET_COURSE_I_CAL), {"p1": course_id}).first()
        if row is None:
            return None
        return row[0]

    def get_courses_list(self) -> Iterator[GetCoursesListRow]:
        result = self._conn.execute(sqlalchemy.text(GET_COURSES_LIST))
        for row in result:
            yield GetCoursesListRow(
                id=row[0],
                name=row[1],
                level=row[2],
                calendar_available=row[3],
                last_sync_at=row[4],
            )

    def login_user(self, *, first_name: Optional[str], last_name: Optional[str], email: Optional[str]) -> Optional[models.User]:
        row = self._conn.execute(sqlalchemy.text(LOGIN_USER), {"p1": first_name, "p2": last_name, "p3": email}).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            first_name=row[1],
            last_name=row[2],
            email=row[3],
            calendar_token=row[4],
            last_login_at=row[5],
            last_calendar_sync_at=row[6],
        )

    def update_calendar_sync_status(self, *, last_sync_at: Optional[str], last_sync_http_status: Optional[int], id: str) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_CALENDAR_SYNC_STATUS), {"p1": last_sync_at, "p2": last_sync_http_status, "p3": id})

    def update_course_i_cal(self, *, course_id: Optional[str], ics_string: Optional[str]) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_COURSE_I_CAL), {"p1": course_id, "p2": ics_string})
